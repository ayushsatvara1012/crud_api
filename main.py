from fastapi import FastAPI, HTTPExceptionfrom pydantic import BaseModelfrom typing import Optionalapp = FastAPI()class Books(BaseModel):	title: str	author: str	year: intclass BookUpdate(BaseModel):	title: Optional[str] = None	author: Optional[str] = None	year: Optional[int] = None# -------------------------------------------------------------------------# Database for the Books# -------------------------------------------------------------------------Books_DB = {	1: {'id': 1, 'title': 'World War', 'author': 'Mr.ABC', 'year': 1234},	2: {'id': 2, 'title': 'Titanic', 'author': 'Mr.Titanic', 'year': 1999},	3: {'id': 3, 'title': 'Comedy King', 'author': 'Mr.Newbie', 'year': 1800}}# -------------------------- Root Endpoint -------------------------- #@app.get('/')def root():	return {		"message": "Welcome to Book Store API!",		"endpoints": {			"GET /books": "Get all books",			"GET /books/{id}": "Get one book",			"GET /books/search": "Search by author/year",			"POST /books": "Create book",			"PUT /books/{id}": "Update book",			"DELETE /books/{id}": "Delete book"		}	}# -------------------------- Create Book -------------------------- #next_id = 4@app.post('/books',status_code=201)def create_book( book_create: Books):	global next_id	new_book = {		'id': next_id,		**book_create.model_dump()	}	Books_DB[next_id] = new_book	next_id += 1	return {		'Status': 'Book Created successfully !!',		'Updated Book': new_book	}# -------------------------- Get All Books -------------------------- #@app.get('/books')def get_all_books():	return {		'total': len(Books_DB),		'List of Books': list(Books_DB.values())	}# -------------------------- Get Single Book -------------------------- #@app.get('/books/{book_id}')def get_book(book_id: int):	if book_id not in Books_DB:		return HTTPException(status_code=404, detail=f'Book of {book_id} is not found !!')	return {		'Book': Books_DB[book_id]	}# -------------------------- Search the book -------------------------- #@app.get('/books/search/')def search_book(author: Optional[str] = None, year: Optional[int] = None):	result = list(Books_DB.values())	if author:		result = [book for book in result if author.lower() in book['author'].lower()]	if year:		result = [book for book in result if year == book['year']]	return {		'Total books': len(result),		'Books': result	}# -------------------------- Update the Book -------------------------- #@app.put('/books/{book_id}')def update_book(book_id: int, book: Books):	"""{  "title": "1984 - Special Edition",  "author": "George Orwell",  "year": 1949,  "pages": 350}"""	if book_id not in Books_DB:		raise HTTPException(status_code=404, detail=f'Book of ID:{book_id} not found !!')	updated_book = {		'id': book_id,		**book.model_dump()	}	Books_DB[book_id] = updated_book	return {		'Status': 'Book Update successfully !!',		'Updated Book': updated_book	}# -------------------------- Partial Update -------------------------- #@app.patch('/books/{book_id}')def partial_book_update(book_id: int, book_update: BookUpdate):	if book_id not in Books_DB:		raise HTTPException(status_code=404, detail=f'Book of ID{book_id} not found')	existing_book = Books_DB[book_id]	update_data = book_update.model_dump(exclude_unset=True)	for key, val in update_data.items():		existing_book[key] = val	Books_DB[book_id] = existing_book	return {		'Status': 'Book Partially Updated',		'Updated Book': existing_book	}# -------------------------- Delete a Book -------------------------- #@app.delete('/books/{book_id}')def delete_book(book_id: int):	if book_id not in Books_DB:		raise HTTPException(status_code=404, detail=f'Book of ID{book_id} not found')	deleted_book = Books_DB.pop(book_id)	return {		'Status': 'Book deleted Successfully',		'Deleted Book': deleted_book	}# -------------------------- Delete All Books -------------------------- #@app.delete('/books')def delete_all_books():	count = len(Books_DB)	Books_DB.clear()	return {		'Status': f"All {count} Books been deleted",		'Remaining books': len(Books_DB)	}