from fastapi import FastAPI, HTTPExceptionfrom pydantic import BaseModelfrom typing import Optional, Listfrom threading import Lockfrom fastapi.middleware.cors import CORSMiddlewareapp = FastAPI()origins = [    'http://localhost:5173',    'http://127.0.0.1:5173'    ]app.add_middleware(CORSMiddleware, allow_origins=origins,allow_credentials=True,allow_methods=['*'],allow_headers=['*'])# -------------------------- Models -------------------------- #class BookCreate(BaseModel):    title: str    author: str    year: intclass BookUpdate(BaseModel):    title: Optional[str] = None    author: Optional[str] = None    year: Optional[int] = Noneclass BookResponse(BaseModel):    id: int    title: str    author: str    year: intclass DeleteResponse(BaseModel):    message: str    book: BookResponse# --------------------------------- Custom Error Classes --------------------------------- #class BookNotFoundError(HTTPException):    def __init__(self, book_id: int):        super().__init__(            status_code=404,            detail=f'Book ID: {book_id} Not found !! Please Try Again !!!'            )# -------------------------------------------------------------------------# Database for the Books# -------------------------------------------------------------------------Books_DB = [    {'id': 1, 'title': 'World War', 'author': 'Mr.ABC', 'year': 1234},    {'id': 2, 'title': 'Titanic', 'author': 'Mr.Titanic', 'year': 1999},    {'id': 3, 'title': 'Comedy King', 'author': 'Mr.Newbie', 'year': 1800}    ]next_id = 4id_lock = Lock()# -------------------------- Helper Functions -------------------------- #def find_book_by_id(book_id: int):    """Find the book by its ID"""    for book in Books_DB:        if book['id'] == book_id:            return book    return Nonedef find_book_index_by_id(book_id: int):    """Find the index of the book by ID"""    for index, book in enumerate(Books_DB):        if book['id'] == book_id:            return index    return None# -------------------------- Root Endpoint -------------------------- #@app.get('/')def root():    return {        "message": "Welcome to Book Store API!",        "endpoints": {            "GET /books": "Get all books",            "GET /books/{id}": "Get one book",            "GET /books/search": "Search by author/year",            "POST /books": "Create book",            "PUT /books/{id}": "Update book",            "DELETE /books/{id}": "Delete book"            }        }# -------------------------- Create Book -------------------------- #@app.post('/books', status_code=201, response_model=BookResponse)def create_book(book_create: BookCreate):    global next_id    with id_lock:        new_id = next_id        next_id += 1    new_book = {        'id': new_id,        **book_create.model_dump()        }    Books_DB.append(new_book)    return new_book# -------------------------- Get All Books -------------------------- #@app.get('/books', response_model=List[BookResponse])def get_all_books():    return Books_DB# -------------------------- Search the book -------------------------- #@app.get('/books/search/', response_model=List[BookResponse])def search_book(author: Optional[str] = None, year: Optional[int] = None):    result = Books_DB.copy()    if author:        result = [book for book in result if author.lower() in book['author'].lower()]    if year:        result = [book for book in result if year == book['year']]    return result# -------------------------- Get Single Book -------------------------- #@app.get('/books/{book_id}', response_model=BookResponse)def get_book(book_id: int):    book = find_book_by_id(book_id)    if not book:        raise BookNotFoundError(book_id)    return book# --------------------------------- Update the Book---------------------------------------- #@app.put('/books/{book_id}', response_model=BookResponse)def update_book(book_id: int, book: BookCreate):    """Update the existing book by using ID"""    index = find_book_index_by_id(book_id)    if index is None:        raise HTTPException(status_code=404, detail=f'Book of ID:{book_id} not Found !!')    updated_book = {        'id': book_id,        **book.model_dump()        }    Books_DB[index] = updated_book    return updated_book# -------------------------- Partial Update -------------------------- #@app.patch('/books/{book_id}', response_model=BookResponse)def partial_book_update(book_id: int, book_update: BookUpdate):    book = find_book_by_id(book_id)    if not book:        raise HTTPException(            status_code=404,            detail=f'Book ID {book_id} not found'            )    updated_data = book_update.model_dump(exclude_unset=True)    for key, val in updated_data.items():        book[key] = val    return book# -------------------------- Delete a Book -------------------------- #@app.delete('/books/{book_id}', response_model=DeleteResponse)def delete_book(book_id: int):    index = find_book_index_by_id(book_id)    if index is None:        raise HTTPException(            status_code=404,            detail=f'Book ID {book_id} not found'            )    deleted_book = Books_DB.pop(index)    return {        'message': 'Book Deleted Successfully !!',        'book': deleted_book        }# -------------------------- Delete All Books -------------------------- #@app.delete('/books')def delete_all_books():    global next_id    count = len(Books_DB)    Books_DB.clear()    next_id = 1    return {        'Status': f"All {count} Books been deleted",        'Remaining books': len(Books_DB)        }